<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        // function Person() {
        //     this.name = "张三";
        //     this.age = 20;
        // }

        // var p =new Person();
        // alert(p.name);
        // 构造函数和原型链中增加方法

        // function Person() {
        //     this.name = "张三";
        //     this.age = 20;
        //     this.run = function() {
        //         alert(this.name + '在运动');
        //     }
        // }
        // // 原型链上的属性会被多个实例共享，构造函数不会
        // Person.prototype.sex = '男';
        // Person.prototype.work = function() {
        //     alert(this.name + '在运动');            
        // }
        // var p =new Person();
        // p.work();
        // 类里面的静态方法

        // function Person() {
        //     this.name = "张三";
        //     this.age = 20;
        //     this.run = function() {
        //         alert(this.name + '在运动');
        //     }
        // }
        // Person.getInfo = function (){
        //     alert('我是静态方法');
        // }
        // // 原型链上的属性会被多个实例共享，构造函数不会
        // Person.prototype.sex = '男';
        // Person.prototype.work = function() {
        //     alert(this.name + '在运动');            
        // }
        // Person.getInfo();

        // es5中的继承
        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.run = function() {
                alert(this.name + '在运动');
            }
        }
        // 原型链上的属性会被多个实例共享，构造函数不会
        Person.prototype.sex = '男';
        Person.prototype.work = function() {
            alert(this.name + '在运动');            
        }
        var p =  new Person('张三', 20);
        console.log(p.name);

        // 对象冒充继承
        // function Web() {
        //     Person.call(this); //对象冒充继承
        // }

        // var w = new Web();
        // w.run();// 对象冒充可以继承构造函数的属性和方法
        // w.work();// 报错 对象冒充可以继承构造函数的属性和方法，但是没法继承原型链上的属性和方法

        // 原型链继承
        // function Web() {
        // }
        // Web.prototype = new Person(); // 实例化子类的时候没办法给父类
        // w = new Web();
        // w.run();//对象冒充可以继承构造函数的属性和方法
        // w.work();//原型链继承可以继承构造函数的属性和方法，也可以继承原型链上的属性和方法,但是实例化子类的时候没办法给父类

        // 对象冒充+原型链组合继承 1
        // function Web(name, age) {
        //     Person.call(this, name, age);
        // }
        // Web.prototype = new Person;
        // var w = new Web('张三', 20);
        // w.run();
        // w.work(); //对象冒充+原型链组合继承可以继承构造函数的属性和方法，也可以继承原型链上的属性和方法,实例化子类的时候可以给父类传参

        // 对象冒充+原型链组合继承 2
        // function Web(name, age) {
        //     Person.call(this, name, age);
        // }
        // Web.prototype = Person.prototype;
        // var w = new Web('张三', 20);
        // w.run();
        // w.work(); //对象冒充+原型链组合继承可以继承构造函数的属性和方法，也可以继承原型链上的属性和方法,实例化子类的时候可以给父类传参
    </script>
</head>
<body>
    
</body>
</html>